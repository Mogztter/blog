<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>(mcorbin.fr): Exploitez vos logs Ansible !</title>
    <link rel="canonical" href="http://mcorbin.fr/posts/10-08-2016-logs-ansible/">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href='http://fonts.googleapis.com/css?family=Alegreya:400italic,700italic,400,700' rel='stylesheet'
          type='text/css'>
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.1/styles/default.min.css">
    <link href="/css/screen.css" rel="stylesheet" type="text/css" />
    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-82339305-1', 'auto');
  ga('send', 'pageview');

    </script>
  </head>
  <body><a name="top"></a>
    <nav class="navbar navbar-default">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="/">(mcorbin.fr)</a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav navbar-right">
            <li ><a href="/">Home</a></li>
            <li
               ><a href="/archives/">Archives</a></li>
            
            <li
               >
              <a href="/pages/about/">A propos/About</a>
            </li>
            
            <li><a href="/feed.xml">RSS</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div><!--/.container-fluid -->
    </nav>


    <div class="container">
      <div class="row">
        <div class="col-lg-9">
          <div id="content">
            
<div id="post">
    <div class="post-header">
    <div id="post-meta" class="row">
        <div class="col-lg-6">10 août 2016</div>
        
    </div>
    <h2>Exploitez vos logs Ansible !</h2>
</div>
<div>
    
    <p>J'utilise Ansible au quotidien. Tous les jours, mes collègues et moi même l'utilisons pour configurer nos serveurs et déployer nos applications, sur de nombreux environnements. Nous utilisons Jenkins pour piloter Ansible.</p><p>Tout cela génère une <strong>énorme</strong> quantité de logs, dont nous ne faisons pas grand chose à part une consultation après un déploiement via l'interface de Jenkins.</p><p>J'expliquerais dans cet article une façon d'exploiter ces logs, en s'appuyant sur les plugins callback d'Ansible. Grâce à ces plugins, il est possible d'obtenir des logs beaucoup plus détaillés que les logs Ansible de base, ainsi que de facilement les manipuler pour en tirer un maximum d'informations et de statistiques.</p><h2><a name="les&#95;callbacks&#95;plugins&#95;d'ansible"></a>Les callbacks plugins d'Ansible</h2><h3><a name="&nbsp;&nbsp;&nbsp;&nbsp;&#95;<strong>présentation&#95;générale</strong>"></a>&nbsp;&nbsp;&nbsp;&nbsp; <strong>Présentation générale</strong></h3><p>Ansible peut être "étendu" avec des plugins. Je vais présenter ici les plugins de type callback <a href='http://docs.ansible.com/ansible/developing_plugins.html#callbacks'>(documentation)</a>. Les examples ici concernent Ansible 1.X, mais le fonctionnement est quasiment identique en version 2 et plus.</p><p>Ce plugin permet de définir un objet dont les fonctions seront appelées à différents moments lors de l'exécution d'Ansible. Exemple :</p><pre><code class="python">class CallbackModule&#40;object&#41;:

    def on&#95;any&#40;self, &#42;args, &#42;&#42;kwargs&#41;:
        pass

    def runner&#95;on&#95;failed&#40;self, host, res, ignore&#95;errors=False&#41;:
        pass

    def runner&#95;on&#95;ok&#40;self, host, res&#41;:
        pass

    def runner&#95;on&#95;skipped&#40;self, host, item=None&#41;:
        pass

    def playbook&#95;on&#95;start&#40;self&#41;:
        pass

    def playbook&#95;on&#95;task&#95;start&#40;self, name, is&#95;conditional&#41;:
        pass

    # etc...

</code></pre><p>Un callback plugin est donc juste un objet implémentant un certain nombre de méthodes. J'en ai mis quelques unes dans cet exemple, mais il en existe beaucoup plus pour tout type d'événements (vous pouvez retrouver ces fonctions dans la doc d'Ansible ou dans les plugins callbacks fournis avec Ansible).</p><h3><a name="&nbsp;&nbsp;&nbsp;&nbsp;&#95;<strong>fonctionnement&#95;détaillé</strong>"></a>&nbsp;&nbsp;&nbsp;&nbsp; <strong>Fonctionnement détaillé</strong></h3><p>Par exemple, la fonction <strong>runner&#95;on&#95;failed</strong> sera appelé quand une task Ansible échouera. De la même façon, <strong>runner&#95;on&#95;ok</strong> sera appelé lorsque qu'une tâche sera en succès, <strong>runner&#95;on&#95;skipped</strong> lors d'une tâche ignorée etc...</p><p>Les fonctions de type <strong>playbook&#95;on_</strong> seront elles exécutées lors d'évènements liés aux playbooks (<strong>playbook&#95;on&#95;start</strong> lors du démarrage du playbook etc...).</p><p>Toutes ces fonctions recoivent des paramètres. C'est là que ça devient intéressant. Par exemple, nous disposons dans <strong>runner&#95;on&#95;ok</strong> des variables <strong>self</strong>, <strong>host</strong>, et <strong>res</strong> :</p><ul><li>Commençons par la variable <strong>host</strong>. Comme son nom l'indique, cette variable contient l'host sur lequel s'applique la task.</li><li>La variable <strong>res</strong> contient les différentes informations sur la machine comme par exemple les variables de type <em>fact</em>, ainsi que quelques informations sur la task (état <em>changed</em>, module appelé...).</li><li>L'objet callback <strong>self</strong> contient un grand nombre d'informations sur l'exécution en cours. Rajoutons par exemple <strong>import pdb; pdb.set_trace();</strong> dans la fonction (pour utiliser le débugger Python) et lançons un déploiement. Un <strong>pp dir(self)</strong> pour lister les champs de l'objet donne:</li></ul><pre><code>&#40;Pdb&#41; pp dir&#40;self&#41;
&#91;'&#95;&#95;class&#95;&#95;',
 '&#95;&#95;delattr&#95;&#95;',
 '&#95;&#95;dict&#95;&#95;',
 '&#95;&#95;doc&#95;&#95;',
 '&#95;&#95;format&#95;&#95;',
 '&#95;&#95;getattribute&#95;&#95;',
 '&#95;&#95;hash&#95;&#95;',
 '&#95;&#95;init&#95;&#95;',
 '&#95;&#95;module&#95;&#95;',
 '&#95;&#95;new&#95;&#95;',
 '&#95;&#95;reduce&#95;&#95;',
 '&#95;&#95;reduce&#95;ex&#95;&#95;',
 '&#95;&#95;repr&#95;&#95;',
 '&#95;&#95;setattr&#95;&#95;',
 '&#95;&#95;sizeof&#95;&#95;',
 '&#95;&#95;str&#95;&#95;',
 '&#95;&#95;subclasshook&#95;&#95;',
 '&#95;&#95;weakref&#95;&#95;',
 'on&#95;any',
 'play',
 'playbook',
 'playbook&#95;on&#95;import&#95;for&#95;host',
 'playbook&#95;on&#95;no&#95;hosts&#95;matched',
 'playbook&#95;on&#95;no&#95;hosts&#95;remaining',
 'playbook&#95;on&#95;not&#95;import&#95;for&#95;host',
 'playbook&#95;on&#95;notify',
 'playbook&#95;on&#95;play&#95;start',
 'playbook&#95;on&#95;setup',
 'playbook&#95;on&#95;start',
 'playbook&#95;on&#95;stats',
 'playbook&#95;on&#95;task&#95;start',
 'playbook&#95;on&#95;vars&#95;prompt',
 'runner&#95;on&#95;async&#95;failed',
 'runner&#95;on&#95;async&#95;ok',
 'runner&#95;on&#95;async&#95;poll',
 'runner&#95;on&#95;failed',
 'runner&#95;on&#95;no&#95;hosts',
 'runner&#95;on&#95;ok',
 'runner&#95;on&#95;skipped',
 'runner&#95;on&#95;unreachable',
 'state',
 'task'&#93;
</code></pre><p>L'objet <strong>self</strong> est une vraie mine d'or ! A coup de pdb (<code>pp dir&#40;self.task&#41;</code>, <code>pp dir&#40;self.play&#41;</code> etc...) on se rend compte que l'on a accès à une énorme quantité d'informations sur notre déploiement. Détail de la tâche en cours (nom, rôle associé...), variables, informations sur le playbook... Il ne reste plus qu'à piocher dans ce qui nous intéresse ! Bien sûr, chaque fonction du plugin callback aura des paramètres différents (même si l'on retrouve des similarités, comme par exemple entre <strong>runner&#95;on&#95;failed</strong> et <strong>runner&#95;on&#95;ok</strong>).</p><h3><a name="&nbsp;&nbsp;&nbsp;&nbsp;&#95;<strong>playbook&#95;on&#95;start</strong>"></a>&nbsp;&nbsp;&nbsp;&nbsp; <strong>playbook on start</strong></h3><p>La méthode <strong>playbook&#95;on&#95;start</strong> s'exécute, comme son nom l'indique, au lancement d'un playbook. Je voulais initialiser quelques variables à partir d'extra&#95;vars, j'ai donc utilisé cette fonction pour le faire. Voici un exemple basique (je considère qu'une fonction <strong>get_timestamp</strong> me retourne le timestamp actuel) :</p><pre><code class="python">def playbook&#95;on&#95;start&#40;self&#41;:
        extra&#95;vars = self.playbook.extra&#95;vars
        self.project = extra&#95;vars&#91;&quot;project&quot;&#93;
        self.version = extra&#95;vars&#91;&quot;version&quot;&#93;
        self.environment = extra&#95;vars&#91;&quot;environment&quot;&#93;
        self.start&#95;timestamp = get&#95;timestamp&#40;&#41;
</code></pre>Ici, je récupère trois variables que je sais présentes en extra_vars. Une variable <strong>projet</strong> (le projet à déployer), une variable <strong>version</strong> (la version à déployer), une variable <strong>environment</strong> (dev, préprod, prod...), et le timestamp du démarrage du déploiement. J'utilise ces quatres informations pour identifier précisément un déploiement.<br/><br/>Bref, il est très facile de pouvoir rendre accessibles certaines variables en enrichissant <strong>self</strong> lors de l'exécution des fonctions (l'objet callback étant toujours le même dans un déploiement). Les autres variables de <strong>self</strong> sont bien sûr également accessibles si besoin.<h3><a name="&nbsp;&nbsp;&nbsp;&nbsp;&#95;<strong>playbook&#95;on&#95;stats</strong>"></a>&nbsp;&nbsp;&nbsp;&nbsp; <strong>playbook on stats</strong></h3><p>Une autre fonction intéressante est <strong>playbook&#95;on&#95;stats</strong>. Cette fonction est appelée à la fin du déploiement, et contient le résumé du déploiement. Voici par exemple la façon de récupérer le résumé (contenant les tasks unreachable, skipped, changed...) du déploiement par host :</p><pre><code class="python">def playbook&#95;on&#95;stats&#40;self, stats&#41;:
    hosts = stats.processed.keys&#40;&#41;
    for h in hosts:
        summary = stats.summarize&#40;h&#41;
</code></pre><p>Je récupère personnellement le résumé du déploiement par host, mais aussi un résumé global en additionnant chaque type de task (ok, skipped...) de chaque host.</p><h2><a name="<strong>la&#95;génération&#95;des&#95;logs</strong>"></a><strong>la génération des logs</strong></h2><p>Il ne vous reste plus qu'à compléter les différentes fonctions du plugin callback pour générer des logs au format souhaité. Voici par exemple un exemple tout bête qui envoie (via http en utilisant le package <strong>requests</strong>) un log à un web server lorsqu'une task échoue:</p><pre><code class="python">def runner&#95;on&#95;failed&#40;self, host, res, ignore&#95;errors=False&#41;:
    task = self.task
    result = {
        &quot;timestamp&quot;: get&#95;timestamp&#40;&#41;,
        &quot;host&quot;: host,
        &quot;type&quot;: &quot;task&#95;failed&quot;,
        &quot;task&quot;: task.name,
        &quot;role&quot;: task.role&#95;name,
        &quot;result&quot;: json.dumps&#40;res&#41;,
        &quot;version&quot;: self.version,  # Cette variable et les suivantes sont initialisées comme précédemment
        &quot;environment&quot;: self.environment,
        &quot;project&quot;: self.project,
        &quot;start&#95;timestamp&quot;: self.start&#95;timestamp
    }
    requests.post&#40;url&#95;web&#95;server, data=json.dumps&#40;result&#41;&#41;
</code></pre><p>On aura ici accès au timestamp, à l'host, au type d'évènement (task_failed), au nom de la task, au rôle associé à la task si il existe, au résultat détaillé de l'exécution de la task, et enfin aux variables définies plus tôt dans <strong>playbook&#95;on&#95;start</strong> (ces variables sont communes à tous les logs d'un même déploiement et permettent ensuite d'identifier les logs pour un déploiement donné).</p><p>Il ne reste plus qu'à écrire un code similaire dans les autres fonctions du plugin callback (en l'adaptant à chaque fois), et on arrive déjà sans grand effort à collecter des logs très intéressants !</p><h2><a name="<strong>collectez&#95;et&#95;stockez&#95;vos&#95;logs</strong>"></a><strong>Collectez et stockez vos logs</strong></h2><p>Les possibilités avec les plugins Ansible sont infinies. J'ai choisi de les envoyer comme dans l'exemple précédent dans un service web (9 lignes de Python avec Flask + kafka-python). Ce service ne réalise qu'une seule chose : après réception d'un log, il l'envoie dans Kafka. Un Logstash collecte ensuite les logs de Kafka pour les indexer dans Elasticsearch. J'ai essayé d'envoyer directement du plugin dans kafka, mais Ansible semble gérer bizarrement le cycle de vie de ses objets, ce qui posait quelques soucis avec kafka-python.</p><p><center><img src="/img/ansible_log.png" alt="Ansible log architecture" /></center></p><p>Vous pourriez très bien écrire les logs sur disque, ou les envoyer dans une base de données... Tout dépend de ce que voulez en faire. L'avantage d'Elasticsearch est qu'il est très facile ensuite de réaliser des requêtes complexes/des graphes sur les logs via Kibana/Grafana.</p><h2><a name="<strong>exploitation&#95;des&#95;logs</strong>"></a><strong>Exploitation des logs</strong></h2><p>Rien qu'avec les informations fournies précédemment par le plugin callback, je peux :</p><ul><li>Réaliser des recherches complexes dans Kibana (exemple : récupérer les tasks en échec pour le rôle HAproxy d'un projet donné ces 90 derniers jours sur la préprod). De plus, tous les logs sont centralisés au même endroit, ça évite d'avoir à se balader de jobs Jenkins en jobs Jenkins pour visualiser les logs (qui sont souvent illisibles avec l'option <strong>-vvvv</strong> d'Ansible)</li><li>Dans Grafana, par projet:<ul><li>Résumé des derniers déploiements (heure de début, environnement, succès ou non, nombre de tasks skipped/changed/unreachable etc...)</li><li>Liste des déploiements lancés (ceux en cours sont donc lancés mais non terminés).</li><li>Nombre de déploiements terminés sur une période de temps</li><li>Nombre de déploiements lancés sur une période de temps (permet de comparer avec le nombre de déploiements terminés).</li><li>Nombre de task pour chaque rôle sur une période de temps en fonction du type de la task (skipped, changed...)</li><li>Nombre de fois qu'un rôle a été en échec.</li><li>Rôles les moins fiables (le plus souvent en échec).</li><li>Temps d'exécution de chaque rôle rôle (minimum, maximum, moyenne...).</li></ul></li><li>Dans Grafana, tous les graphes cités précédemment mais de façon globale (donc sans la notion de projet).</li></ul><p><center><img src="/img/ansible_grafana1.png" alt="Exemple de graphes avec Grafana" /></center></p><p><center><img src="/img/ansible_grafana2.png" alt="Exemple de graphes avec Grafana" /></center></p><p><center><em>Ces deux images présentent quelques graphes Grafana (anonymisées) générés via les statistiques récoltées par le plugin. Liens vers les images en tailles réelles <a href='/img/ansible_grafana1.png'>ici</a> et <a href='/img/ansible_grafana2.png'>ici</a></em></center></p><p><br/> Le temps par rôle peut être calculé assez simplement. Lors de l'exécution d'une task, on a accès dans le plugin au rôle associé à la task. J'initialise un dictionnaire où la clé est le nom du rôle, et la valeur un tableau de deux élements. Le premier élément est le timestamp de la première task du rôle. Je mets ensuite à jour le second élément (la date de fin du rôle) à chaque nouvelle task. J'envoie ensuite ces statistiques pour chaque rôle (si il n'y a pas eu de plantage pouvant causer de fausses durées) en fin de déploiement.</p><p>Pensez également à pré-traiter certains logs, comme par exemple les paramètres <strong>res</strong> des fonctions. Ces paramètres peuvent être trèèèèès longs (des dizaines de milliers de caractères), notamment lors de téléchargements volumineux avec Ansible en mode <strong>-vvvv</strong>. Je remplace généralement les résultats trop longs par un message de type <em>résultat trop long</em> (ce sont généralement des données inexploitables).</p><h2><a name="<strong>ansible&#95;2</strong>"></a><strong>Ansible 2</strong></h2><p>Le <a href='https://docs.ansible.com/ansible/porting_guide_2.0.html'>porting guide</a> d'Ansible livre quelques informations pour porter les plugins Callback en Ansible 2. Malheureusement, le fonctionnement interne d'Ansible ayant bougé, il faudra réadapter le code. En vrac :</p><ul><li>Les extra_vars ne sont plus accessibles dans <strong>playbook&#95;on&#95;start</strong> mais seulement à partir de <strong>v2&#95;playbook&#95;on&#95;play&#95;start</strong>, et d'une façon un peu différente :</li></ul><pre><code class="python">extra&#95;vars = play.get&#95;variable&#95;manager&#40;&#41;.extra&#95;vars
</code></pre><ul><li>Le nom du rôle est accessible dans <strong>v2&#95;playbook&#95;on&#95;task&#95;start</strong>. Pour garder une certaine compatibilité avec du code Ansible 1.X, vous pouvez faire :</li></ul><pre><code class="python">if task.&#95;role is not None:  # on verifie si c'est un role ou non
    task.role&#95;name = task.&#95;role.&#95;role&#95;name
</code></pre><h2><a name="<strong>conclusion</strong>"></a><strong>Conclusion</strong></h2><p>Les possibilités du plugin callback sont infinies. Je pense sincèrement qu'en prenant le temps, il est possible de réaliser de nombreuses statistiques sur les déploiements (ainsi que de l'alerting, de la corrélation avec d'autres métriques comme des métriques systèmes...), surtout avec des outils puissants comme Kibana/Grafana. Bref, à creuser !</p>
</div>

<div id="post-tags">
    <b>Tags: </b>
    
    <a href="/tags/ansible/">ansible</a>
    
</div>


    <div id="prev-next">
        
        
        <a class="right" href="/posts/22-04-2016-lesspipe/">Un jour une manpage / one day one manpage: lesspipe &raquo;</a>
        
    </div>

    


</div>

            <a href="#top">Retour en haut de page</a>
          </div>
        </div>

        <div class="col-md-3">
          <div id="sidebar">
            <h3>Links</h3>
            <ul id="links">
              <li>- <a href="http://clojure.org/">clojure.org</a></li>
            
            <div id="recent">
              <h3>Recent posts</h3>
              <ul>
                
                <li>- <a href="/posts/10-08-2016-logs-ansible/">Exploitez vos logs Ansible !</a></li>
                
                <li>- <a href="/posts/22-04-2016-lesspipe/">Un jour une manpage / one day one manpage: lesspipe</a></li>
                
              </ul>
            </div>
            
            
            <div id="tags">
              <h3>Tags</h3>
              <ul>
                
                <li>- <a href="/tags/ansible/">ansible</a></li>
                
                <li>- <a href="/tags/linux/">linux</a></li>
                
                <li>- <a href="/tags/manpage/">manpage</a></li>
                
              </ul>
            </div>
            
          </div>
        </div>
      </div>
      <footer>Copyright &copy;  mcorbin
        <p style="text-align: center;">Powered by <a href="http://cryogenweb.org">Cryogen</a></p></footer>
    </div>
    <script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
    <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.0/js/bootstrap.min.js"></script>
    <script src="/js/highlight.pack.js" type="text/javascript"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>

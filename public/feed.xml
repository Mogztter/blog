<?xml version='1.0' encoding='UTF-8'?>
<rss version='2.0' xmlns:atom='http://www.w3.org/2005/Atom'>
<channel>
<atom:link href='http://mcorbin.fr' rel='self' type='application/rss+xml'/>
<title>
(mcorbin.fr)
</title>
<link>
http://mcorbin.fr
</link>
<description>
Blog de mcorbin
</description>
<lastBuildDate>
Sun, 04 Dec 2016 21:59:28 +0100
</lastBuildDate>
<generator>
clj-rss
</generator>
<item>
<guid>
http://mcorbin.fr/posts/10-08-2016-logs-ansible/
</guid>
<link>
http://mcorbin.fr/posts/10-08-2016-logs-ansible/
</link>
<title>
Exploitez vos logs Ansible !
</title>
<description>
&lt;p&gt;J'utilise Ansible au quotidien. Tous les jours, mes collègues et moi même l'utilisons pour configurer nos serveurs et déployer nos applications, sur de nombreux environnements. Nous utilisons Jenkins pour piloter Ansible.&lt;/p&gt;&lt;p&gt;Tout cela génère une &lt;strong&gt;énorme&lt;/strong&gt; quantité de logs, dont nous ne faisons pas grand chose à part une consultation après un déploiement via l'interface de Jenkins.&lt;/p&gt;&lt;p&gt;J'expliquerais dans cet article une façon d'exploiter ces logs, en s'appuyant sur les plugins callback d'Ansible. Grâce à ces plugins, il est possible d'obtenir des logs beaucoup plus détaillés que les logs Ansible de base, ainsi que de facilement les manipuler pour en tirer un maximum d'informations et de statistiques.&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;les&amp;#95;callbacks&amp;#95;plugins&amp;#95;d'ansible&quot;&gt;&lt;/a&gt;Les callbacks plugins d'Ansible&lt;/h2&gt;&lt;h3&gt;&lt;a name=&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;#95;&lt;strong&gt;présentation&amp;#95;générale&lt;/strong&gt;&quot;&gt;&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;Présentation générale&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;Ansible peut être &quot;étendu&quot; avec des plugins. Je vais présenter ici les plugins de type callback &lt;a href='http://docs.ansible.com/ansible/developing_plugins.html#callbacks'&gt;(documentation)&lt;/a&gt;. Les examples ici concernent Ansible 1.X, mais le fonctionnement est quasiment identique en version 2 et plus.&lt;/p&gt;&lt;p&gt;Ce plugin permet de définir un objet dont les fonctions seront appelées à différents moments lors de l'exécution d'Ansible. Exemple :&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;class CallbackModule&amp;#40;object&amp;#41;:

    def on&amp;#95;any&amp;#40;self, &amp;#42;args, &amp;#42;&amp;#42;kwargs&amp;#41;:
        pass

    def runner&amp;#95;on&amp;#95;failed&amp;#40;self, host, res, ignore&amp;#95;errors=False&amp;#41;:
        pass

    def runner&amp;#95;on&amp;#95;ok&amp;#40;self, host, res&amp;#41;:
        pass

    def runner&amp;#95;on&amp;#95;skipped&amp;#40;self, host, item=None&amp;#41;:
        pass

    def playbook&amp;#95;on&amp;#95;start&amp;#40;self&amp;#41;:
        pass

    def playbook&amp;#95;on&amp;#95;task&amp;#95;start&amp;#40;self, name, is&amp;#95;conditional&amp;#41;:
        pass

    # etc...

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Un callback plugin est donc juste un objet implémentant un certain nombre de méthodes. J'en ai mis quelques unes dans cet exemple, mais il en existe beaucoup plus pour tout type d'événements (vous pouvez retrouver ces fonctions dans la doc d'Ansible ou dans les plugins callbacks fournis avec Ansible).&lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;#95;&lt;strong&gt;fonctionnement&amp;#95;détaillé&lt;/strong&gt;&quot;&gt;&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;Fonctionnement détaillé&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;Par exemple, la fonction &lt;strong&gt;runner&amp;#95;on&amp;#95;failed&lt;/strong&gt; sera appelé quand une task Ansible échouera. De la même façon, &lt;strong&gt;runner&amp;#95;on&amp;#95;ok&lt;/strong&gt; sera appelé lorsque qu'une tâche sera en succès, &lt;strong&gt;runner&amp;#95;on&amp;#95;skipped&lt;/strong&gt; lors d'une tâche ignorée etc...&lt;/p&gt;&lt;p&gt;Les fonctions de type &lt;strong&gt;playbook&amp;#95;on_&lt;/strong&gt; seront elles exécutées lors d'évènements liés aux playbooks (&lt;strong&gt;playbook&amp;#95;on&amp;#95;start&lt;/strong&gt; lors du démarrage du playbook etc...).&lt;/p&gt;&lt;p&gt;Toutes ces fonctions recoivent des paramètres. C'est là que ça devient intéressant. Par exemple, nous disposons dans &lt;strong&gt;runner&amp;#95;on&amp;#95;ok&lt;/strong&gt; des variables &lt;strong&gt;self&lt;/strong&gt;, &lt;strong&gt;host&lt;/strong&gt;, et &lt;strong&gt;res&lt;/strong&gt; :&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Commençons par la variable &lt;strong&gt;host&lt;/strong&gt;. Comme son nom l'indique, cette variable contient l'host sur lequel s'applique la task.&lt;/li&gt;&lt;li&gt;La variable &lt;strong&gt;res&lt;/strong&gt; contient les différentes informations sur la machine comme par exemple les variables de type &lt;em&gt;fact&lt;/em&gt;, ainsi que quelques informations sur la task (état &lt;em&gt;changed&lt;/em&gt;, module appelé...).&lt;/li&gt;&lt;li&gt;L'objet callback &lt;strong&gt;self&lt;/strong&gt; contient un grand nombre d'informations sur l'exécution en cours. Rajoutons par exemple &lt;strong&gt;import pdb; pdb.set_trace();&lt;/strong&gt; dans la fonction (pour utiliser le débugger Python) et lançons un déploiement. Un &lt;strong&gt;pp dir(self)&lt;/strong&gt; pour lister les champs de l'objet donne:&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;Pdb&amp;#41; pp dir&amp;#40;self&amp;#41;
&amp;#91;'&amp;#95;&amp;#95;class&amp;#95;&amp;#95;',
 '&amp;#95;&amp;#95;delattr&amp;#95;&amp;#95;',
 '&amp;#95;&amp;#95;dict&amp;#95;&amp;#95;',
 '&amp;#95;&amp;#95;doc&amp;#95;&amp;#95;',
 '&amp;#95;&amp;#95;format&amp;#95;&amp;#95;',
 '&amp;#95;&amp;#95;getattribute&amp;#95;&amp;#95;',
 '&amp;#95;&amp;#95;hash&amp;#95;&amp;#95;',
 '&amp;#95;&amp;#95;init&amp;#95;&amp;#95;',
 '&amp;#95;&amp;#95;module&amp;#95;&amp;#95;',
 '&amp;#95;&amp;#95;new&amp;#95;&amp;#95;',
 '&amp;#95;&amp;#95;reduce&amp;#95;&amp;#95;',
 '&amp;#95;&amp;#95;reduce&amp;#95;ex&amp;#95;&amp;#95;',
 '&amp;#95;&amp;#95;repr&amp;#95;&amp;#95;',
 '&amp;#95;&amp;#95;setattr&amp;#95;&amp;#95;',
 '&amp;#95;&amp;#95;sizeof&amp;#95;&amp;#95;',
 '&amp;#95;&amp;#95;str&amp;#95;&amp;#95;',
 '&amp;#95;&amp;#95;subclasshook&amp;#95;&amp;#95;',
 '&amp;#95;&amp;#95;weakref&amp;#95;&amp;#95;',
 'on&amp;#95;any',
 'play',
 'playbook',
 'playbook&amp;#95;on&amp;#95;import&amp;#95;for&amp;#95;host',
 'playbook&amp;#95;on&amp;#95;no&amp;#95;hosts&amp;#95;matched',
 'playbook&amp;#95;on&amp;#95;no&amp;#95;hosts&amp;#95;remaining',
 'playbook&amp;#95;on&amp;#95;not&amp;#95;import&amp;#95;for&amp;#95;host',
 'playbook&amp;#95;on&amp;#95;notify',
 'playbook&amp;#95;on&amp;#95;play&amp;#95;start',
 'playbook&amp;#95;on&amp;#95;setup',
 'playbook&amp;#95;on&amp;#95;start',
 'playbook&amp;#95;on&amp;#95;stats',
 'playbook&amp;#95;on&amp;#95;task&amp;#95;start',
 'playbook&amp;#95;on&amp;#95;vars&amp;#95;prompt',
 'runner&amp;#95;on&amp;#95;async&amp;#95;failed',
 'runner&amp;#95;on&amp;#95;async&amp;#95;ok',
 'runner&amp;#95;on&amp;#95;async&amp;#95;poll',
 'runner&amp;#95;on&amp;#95;failed',
 'runner&amp;#95;on&amp;#95;no&amp;#95;hosts',
 'runner&amp;#95;on&amp;#95;ok',
 'runner&amp;#95;on&amp;#95;skipped',
 'runner&amp;#95;on&amp;#95;unreachable',
 'state',
 'task'&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;L'objet &lt;strong&gt;self&lt;/strong&gt; est une vraie mine d'or ! A coup de pdb (&lt;code&gt;pp dir&amp;#40;self.task&amp;#41;&lt;/code&gt;, &lt;code&gt;pp dir&amp;#40;self.play&amp;#41;&lt;/code&gt; etc...) on se rend compte que l'on a accès à une énorme quantité d'informations sur notre déploiement. Détail de la tâche en cours (nom, rôle associé...), variables, informations sur le playbook... Il ne reste plus qu'à piocher dans ce qui nous intéresse ! Bien sûr, chaque fonction du plugin callback aura des paramètres différents (même si l'on retrouve des similarités, comme par exemple entre &lt;strong&gt;runner&amp;#95;on&amp;#95;failed&lt;/strong&gt; et &lt;strong&gt;runner&amp;#95;on&amp;#95;ok&lt;/strong&gt;).&lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;#95;&lt;strong&gt;playbook&amp;#95;on&amp;#95;start&lt;/strong&gt;&quot;&gt;&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;playbook on start&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;La méthode &lt;strong&gt;playbook&amp;#95;on&amp;#95;start&lt;/strong&gt; s'exécute, comme son nom l'indique, au lancement d'un playbook. Je voulais initialiser quelques variables à partir d'extra&amp;#95;vars, j'ai donc utilisé cette fonction pour le faire. Voici un exemple basique (je considère qu'une fonction &lt;strong&gt;get_timestamp&lt;/strong&gt; me retourne le timestamp actuel) :&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;def playbook&amp;#95;on&amp;#95;start&amp;#40;self&amp;#41;:
        extra&amp;#95;vars = self.playbook.extra&amp;#95;vars
        self.project = extra&amp;#95;vars&amp;#91;&amp;quot;project&amp;quot;&amp;#93;
        self.version = extra&amp;#95;vars&amp;#91;&amp;quot;version&amp;quot;&amp;#93;
        self.environment = extra&amp;#95;vars&amp;#91;&amp;quot;environment&amp;quot;&amp;#93;
        self.start&amp;#95;timestamp = get&amp;#95;timestamp&amp;#40;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;Ici, je récupère trois variables que je sais présentes en extra_vars. Une variable &lt;strong&gt;projet&lt;/strong&gt; (le projet à déployer), une variable &lt;strong&gt;version&lt;/strong&gt; (la version à déployer), une variable &lt;strong&gt;environment&lt;/strong&gt; (dev, préprod, prod...), et le timestamp du démarrage du déploiement. J'utilise ces quatres informations pour identifier précisément un déploiement.&lt;br/&gt;&lt;br/&gt;Bref, il est très facile de pouvoir rendre accessibles certaines variables en enrichissant &lt;strong&gt;self&lt;/strong&gt; lors de l'exécution des fonctions (l'objet callback étant toujours le même dans un déploiement). Les autres variables de &lt;strong&gt;self&lt;/strong&gt; sont bien sûr également accessibles si besoin.&lt;h3&gt;&lt;a name=&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;#95;&lt;strong&gt;playbook&amp;#95;on&amp;#95;stats&lt;/strong&gt;&quot;&gt;&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;strong&gt;playbook on stats&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;Une autre fonction intéressante est &lt;strong&gt;playbook&amp;#95;on&amp;#95;stats&lt;/strong&gt;. Cette fonction est appelée à la fin du déploiement, et contient le résumé du déploiement. Voici par exemple la façon de récupérer le résumé (contenant les tasks unreachable, skipped, changed...) du déploiement par host :&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;def playbook&amp;#95;on&amp;#95;stats&amp;#40;self, stats&amp;#41;:
    hosts = stats.processed.keys&amp;#40;&amp;#41;
    for h in hosts:
        summary = stats.summarize&amp;#40;h&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Je récupère personnellement le résumé du déploiement par host, mais aussi un résumé global en additionnant chaque type de task (ok, skipped...) de chaque host.&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;&lt;strong&gt;la&amp;#95;génération&amp;#95;des&amp;#95;logs&lt;/strong&gt;&quot;&gt;&lt;/a&gt;&lt;strong&gt;la génération des logs&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;Il ne vous reste plus qu'à compléter les différentes fonctions du plugin callback pour générer des logs au format souhaité. Voici par exemple un exemple tout bête qui envoie (via http en utilisant le package &lt;strong&gt;requests&lt;/strong&gt;) un log à un web server lorsqu'une task échoue:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;def runner&amp;#95;on&amp;#95;failed&amp;#40;self, host, res, ignore&amp;#95;errors=False&amp;#41;:
    task = self.task
    result = {
        &amp;quot;timestamp&amp;quot;: get&amp;#95;timestamp&amp;#40;&amp;#41;,
        &amp;quot;host&amp;quot;: host,
        &amp;quot;type&amp;quot;: &amp;quot;task&amp;#95;failed&amp;quot;,
        &amp;quot;task&amp;quot;: task.name,
        &amp;quot;role&amp;quot;: task.role&amp;#95;name,
        &amp;quot;result&amp;quot;: json.dumps&amp;#40;res&amp;#41;,
        &amp;quot;version&amp;quot;: self.version,  # Cette variable et les suivantes sont initialisées comme précédemment
        &amp;quot;environment&amp;quot;: self.environment,
        &amp;quot;project&amp;quot;: self.project,
        &amp;quot;start&amp;#95;timestamp&amp;quot;: self.start&amp;#95;timestamp
    }
    requests.post&amp;#40;url&amp;#95;web&amp;#95;server, data=json.dumps&amp;#40;result&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;On aura ici accès au timestamp, à l'host, au type d'évènement (task_failed), au nom de la task, au rôle associé à la task si il existe, au résultat détaillé de l'exécution de la task, et enfin aux variables définies plus tôt dans &lt;strong&gt;playbook&amp;#95;on&amp;#95;start&lt;/strong&gt; (ces variables sont communes à tous les logs d'un même déploiement et permettent ensuite d'identifier les logs pour un déploiement donné).&lt;/p&gt;&lt;p&gt;Il ne reste plus qu'à écrire un code similaire dans les autres fonctions du plugin callback (en l'adaptant à chaque fois), et on arrive déjà sans grand effort à collecter des logs très intéressants !&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;&lt;strong&gt;collectez&amp;#95;et&amp;#95;stockez&amp;#95;vos&amp;#95;logs&lt;/strong&gt;&quot;&gt;&lt;/a&gt;&lt;strong&gt;Collectez et stockez vos logs&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;Les possibilités avec les plugins Ansible sont infinies. J'ai choisi de les envoyer comme dans l'exemple précédent dans un service web (9 lignes de Python avec Flask + kafka-python). Ce service ne réalise qu'une seule chose : après réception d'un log, il l'envoie dans Kafka. Un Logstash collecte ensuite les logs de Kafka pour les indexer dans Elasticsearch. J'ai essayé d'envoyer directement du plugin dans kafka, mais Ansible semble gérer bizarrement le cycle de vie de ses objets, ce qui posait quelques soucis avec kafka-python.&lt;/p&gt;&lt;p&gt;&lt;center&gt;&lt;img src=&quot;/img/ansible_log.png&quot; alt=&quot;Ansible log architecture&quot; /&gt;&lt;/center&gt;&lt;/p&gt;&lt;p&gt;Vous pourriez très bien écrire les logs sur disque, ou les envoyer dans une base de données... Tout dépend de ce que voulez en faire. L'avantage d'Elasticsearch est qu'il est très facile ensuite de réaliser des requêtes complexes/des graphes sur les logs via Kibana/Grafana.&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;&lt;strong&gt;exploitation&amp;#95;des&amp;#95;logs&lt;/strong&gt;&quot;&gt;&lt;/a&gt;&lt;strong&gt;Exploitation des logs&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;Rien qu'avec les informations fournies précédemment par le plugin callback, je peux :&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Réaliser des recherches complexes dans Kibana (exemple : récupérer les tasks en échec pour le rôle HAproxy d'un projet donné ces 90 derniers jours sur la préprod). De plus, tous les logs sont centralisés au même endroit, ça évite d'avoir à se balader de jobs Jenkins en jobs Jenkins pour visualiser les logs (qui sont souvent illisibles avec l'option &lt;strong&gt;-vvvv&lt;/strong&gt; d'Ansible)&lt;/li&gt;&lt;li&gt;Dans Grafana, par projet:&lt;ul&gt;&lt;li&gt;Résumé des derniers déploiements (heure de début, environnement, succès ou non, nombre de tasks skipped/changed/unreachable etc...)&lt;/li&gt;&lt;li&gt;Liste des déploiements lancés (ceux en cours sont donc lancés mais non terminés).&lt;/li&gt;&lt;li&gt;Nombre de déploiements terminés sur une période de temps&lt;/li&gt;&lt;li&gt;Nombre de déploiements lancés sur une période de temps (permet de comparer avec le nombre de déploiements terminés).&lt;/li&gt;&lt;li&gt;Nombre de task pour chaque rôle sur une période de temps en fonction du type de la task (skipped, changed...)&lt;/li&gt;&lt;li&gt;Nombre de fois qu'un rôle a été en échec.&lt;/li&gt;&lt;li&gt;Rôles les moins fiables (le plus souvent en échec).&lt;/li&gt;&lt;li&gt;Temps d'exécution de chaque rôle rôle (minimum, maximum, moyenne...).&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Dans Grafana, tous les graphes cités précédemment mais de façon globale (donc sans la notion de projet).&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;center&gt;&lt;img src=&quot;/img/ansible_grafana1.png&quot; alt=&quot;Exemple de graphes avec Grafana&quot; /&gt;&lt;/center&gt;&lt;/p&gt;&lt;p&gt;&lt;center&gt;&lt;img src=&quot;/img/ansible_grafana2.png&quot; alt=&quot;Exemple de graphes avec Grafana&quot; /&gt;&lt;/center&gt;&lt;/p&gt;&lt;p&gt;&lt;center&gt;&lt;em&gt;Ces deux images présentent quelques graphes Grafana (anonymisées) générés via les statistiques récoltées par le plugin. Liens vers les images en tailles réelles &lt;a href='/img/ansible_grafana1.png'&gt;ici&lt;/a&gt; et &lt;a href='/img/ansible_grafana2.png'&gt;ici&lt;/a&gt;&lt;/em&gt;&lt;/center&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt; Le temps par rôle peut être calculé assez simplement. Lors de l'exécution d'une task, on a accès dans le plugin au rôle associé à la task. J'initialise un dictionnaire où la clé est le nom du rôle, et la valeur un tableau de deux élements. Le premier élément est le timestamp de la première task du rôle. Je mets ensuite à jour le second élément (la date de fin du rôle) à chaque nouvelle task. J'envoie ensuite ces statistiques pour chaque rôle (si il n'y a pas eu de plantage pouvant causer de fausses durées) en fin de déploiement.&lt;/p&gt;&lt;p&gt;Pensez également à pré-traiter certains logs, comme par exemple les paramètres &lt;strong&gt;res&lt;/strong&gt; des fonctions. Ces paramètres peuvent être trèèèèès longs (des dizaines de milliers de caractères), notamment lors de téléchargements volumineux avec Ansible en mode &lt;strong&gt;-vvvv&lt;/strong&gt;. Je remplace généralement les résultats trop longs par un message de type &lt;em&gt;résultat trop long&lt;/em&gt; (ce sont généralement des données inexploitables).&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;&lt;strong&gt;ansible&amp;#95;2&lt;/strong&gt;&quot;&gt;&lt;/a&gt;&lt;strong&gt;Ansible 2&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;Le &lt;a href='https://docs.ansible.com/ansible/porting_guide_2.0.html'&gt;porting guide&lt;/a&gt; d'Ansible livre quelques informations pour porter les plugins Callback en Ansible 2. Malheureusement, le fonctionnement interne d'Ansible ayant bougé, il faudra réadapter le code. En vrac :&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Les extra_vars ne sont plus accessibles dans &lt;strong&gt;playbook&amp;#95;on&amp;#95;start&lt;/strong&gt; mais seulement à partir de &lt;strong&gt;v2&amp;#95;playbook&amp;#95;on&amp;#95;play&amp;#95;start&lt;/strong&gt;, et d'une façon un peu différente :&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;extra&amp;#95;vars = play.get&amp;#95;variable&amp;#95;manager&amp;#40;&amp;#41;.extra&amp;#95;vars
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;Le nom du rôle est accessible dans &lt;strong&gt;v2&amp;#95;playbook&amp;#95;on&amp;#95;task&amp;#95;start&lt;/strong&gt;. Pour garder une certaine compatibilité avec du code Ansible 1.X, vous pouvez faire :&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;if task.&amp;#95;role is not None:  # on verifie si c'est un role ou non
    task.role&amp;#95;name = task.&amp;#95;role.&amp;#95;role&amp;#95;name
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;a name=&quot;&lt;strong&gt;conclusion&lt;/strong&gt;&quot;&gt;&lt;/a&gt;&lt;strong&gt;Conclusion&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;Les possibilités du plugin callback sont infinies. Je pense sincèrement qu'en prenant le temps, il est possible de réaliser de nombreuses statistiques sur les déploiements (ainsi que de l'alerting, de la corrélation avec d'autres métriques comme des métriques systèmes...), surtout avec des outils puissants comme Kibana/Grafana. Bref, à creuser !&lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Wed, 10 Aug 2016 00:00:00 +0200
</pubDate>
</item>
<item>
<guid>
http://mcorbin.fr/posts/22-04-2016-lesspipe/
</guid>
<link>
http://mcorbin.fr/posts/22-04-2016-lesspipe/
</link>
<title>
Un jour une manpage / one day one manpage: lesspipe
</title>
<description>
&lt;p&gt;English version &lt;a href='https://mcorbin.fr/pages/lesspipe'&gt;here&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;Le concept de &quot;un jour une manpage&quot; est simple : je choisis une manpage aléatoirement et j'explore la commande associée.&lt;/em&gt;&lt;/p&gt;&lt;p&gt;Aujourd'hui, c'est la commande &lt;strong&gt;lesspipe&lt;/strong&gt; qui sera passée à la loupe. Tout d'abord, regardons ce que raconte un &lt;strong&gt;man lesspipe&lt;/strong&gt; :&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt; lessfile, lesspipe - &quot;input preprocessor&quot; for  less.  lessfile and lesspipe are programs that can be used to modify the  way  the contents of a file are displayed in less &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Cette commande permet donc de manipuler le contenu d'un fichier avant de l'envoyer à &lt;strong&gt;less&lt;/strong&gt;. Pourquoi faire ? Essayez de lancer &lt;strong&gt;less&lt;/strong&gt; sur une image, un .deb ou un .tar.gz... Vous aurez quelques soucis. Lesspipe permet donc (entre autre) d'enrichir less pour explorer de nouveaux types de fichier.&lt;/p&gt;&lt;p&gt;Pour l'activer, il suffit de lancer (ou de rajouter dans son .bashrc ou équivalent) :&lt;/p&gt;&lt;pre&gt;&lt;code&gt;eval &amp;quot;$&amp;#40;lesspipe&amp;#41;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;a name=&quot;comment&amp;#95;ça&amp;#95;marche&amp;#95;?&quot;&gt;&lt;/a&gt;Comment ça marche ?&lt;/h2&gt;&lt;p&gt;Lançons juste &lt;strong&gt;lesspipe&lt;/strong&gt; dans un terminal. On obtient :&lt;/p&gt;&lt;pre&gt;&lt;code&gt;export LESSOPEN=&amp;quot;| /usr/bin/lesspipe %s&amp;quot;;
export LESSCLOSE=&amp;quot;/usr/bin/lesspipe %s %s&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Deux variables sont donc définies: LESSOPEN et LESSCLOSE.&lt;/p&gt;&lt;p&gt;La man page de &lt;strong&gt;less&lt;/strong&gt; indique, dans la partie &lt;strong&gt;INPUT PREPROCESSOR&lt;/strong&gt;, que la variable LESSOPEN sert à activer un préprocesseur pour less. Ce préprocesseur reçoit en paramètre le nom du fichier envoyé à less, crée un fichier temporaire et renvoie en sortie le nom de ce fichier temporaire. Le nom du fichier temporaire sera ensuite utilisé par less.&lt;/p&gt;&lt;p&gt;Le préprocesseur peut également envoyer directement à &lt;strong&gt;less&lt;/strong&gt; des informations sans créer de fichiers temporaires. Dans ce cas là, tout ce qui sera envoyé sur la sortie standard du script appelé par LESSOPEN sera transmis à &lt;strong&gt;less&lt;/strong&gt;.  La man page de &lt;strong&gt;less&lt;/strong&gt; indique à ce sujet:&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;It is also possible to set up an input preprocessor to pipe the file  data  directly to less, rather than putting the data into a replacement file. [...] To use an input pipe, make the first character in the LESSOPEN environment variable a vertical bar (|) to  signify  that  the  input  pre-processor is an input pipe. &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;On remarque que lesspipe ne créera pas de fichiers temporaires (le script commence pr un &lt;strong&gt;|&lt;/strong&gt;).&lt;/p&gt;&lt;p&gt;Dans notre cas, quand &lt;strong&gt;less&lt;/strong&gt; sera appelée, le script &lt;code&gt;/usr/bin/lesspipe&lt;/code&gt; sera appelé avec comme paramètre le nom du fichier sur lequel less est appelé. Essayons d'appeler &lt;code&gt;/usr/bin/lesspipe&lt;/code&gt; manuellement, par exemple sur une image :&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ lesspipe myimage.png
myimage.png PNG 254x29 1920x1080+12+134 8-bit sRGB 3.69KB 0.000u 0:00.000
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;On voit que lesspipe retourne certaines informations sur l'image. Ces informations seront passées à &lt;strong&gt;less&lt;/strong&gt; et affichées.&lt;/p&gt;&lt;p&gt;Pour LESSCLOSE, voici une partie intéressante de la man page de less :&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;When less closes a file opened in such a way, it will call another program, called  the  input  postprocessor,  which  may perform any desired clean-up action. &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;LESSCLOSE sert donc à faire le nettoyage. Le script référencé par LESSCLOSE reçoit deux paramètres : le nom du fichier original (sur lequel on a appelé &lt;strong&gt;less&lt;/strong&gt;), et le nom du fichier temporaire (généré par le script LESSOPEN).&lt;/p&gt;&lt;p&gt;On peut maintenant utiliser &lt;strong&gt;less&lt;/strong&gt; sur de nombreux types de fichiers. Par exemple, less sur un .zip affichera les fichiers contenus dans cette archive. Même chose pour de nombreux autres formats comme tar, deb, rpm, iso, pdf... Et même des images !&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;source-highlight&quot;&gt;&lt;/a&gt;source-highlight&lt;/h2&gt;&lt;p&gt;Dans le même genre, source-highlight permet de rajouter de la coloration syntaxique à less. Pour l'installer (sur Debian), c'est simple :&lt;/p&gt;&lt;pre&gt;&lt;code&gt;sudo apt-get install source-highlight
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;On se retrouve ensuite avec un script dans &lt;strong&gt;/usr/share/source-highlight/src-hilite-lesspipe.sh&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;De la même façon que pour lesspipe, utilisons ce script comme préprocesseur :&lt;/p&gt;&lt;pre&gt;&lt;code&gt;export LESSOPEN=&amp;quot;| /usr/share/source-highlight/src-hilite-lesspipe.sh %s&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;less -R [votre fichier] vous ouvrira le fichier avec la coloration syntaxique.&lt;/p&gt;&lt;p&gt;En conclusion, grâce aux deux variables d'environnements (LESSOPEN and LESSCLOSE) vues précédemment, vous pouvez même facilement écrire vos propres scripts pour enrichir less.&lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Fri, 22 Apr 2016 00:00:00 +0200
</pubDate>
</item>
</channel>
</rss>
